
<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000000;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            color: #ffffff;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            font-weight: bold;
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 5px;
        }

        a {
            color: #0040ff;
        }
    </style>
</head>
<body>
    <script src="lib/dat.gui.js"></script>
    <script src="js/ui.js"></script>
    <script src="js/three.js"></script>
    <script src="js/GPGPU.js"></script>
    <script src="js/GeometryUtils.js"></script>
    <script src="js/gpgpu/SimulationShader.js"></script>
    <script src="lib/OrbitControls.js"></script>
    <script src="js/leap-0.6.4.min.js"></script>
    <script src="js/leap-plugins-0.1.6.1.js"></script>
    <script src="js/leap.rigged-hand-0.1.3.min.js"></script>
    
    <script src="helvetiker_bold.typeface.js"></script>
    <!-- WebGL 1 shaders -->
    <script id="vs-particles" type="x-shader/x-vertex">
        uniform sampler2D map;
        uniform float width;
        uniform float height;
        uniform float pointSize;
        varying vec2 vUv;
        varying vec4 vPosition;
        void main() {
        vUv = position.xy + vec2( 0.5 / width, 0.5 / height );
        vec3 color = texture2D( map, vUv ).rgb;
        gl_PointSize = pointSize;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( color, 1.0 );
        }
    </script>
    <script id="fs-particles" type="x-shader/x-fragment">
        uniform sampler2D map;
        varying vec2 vUv;
        varying vec4 vPosition;
        void main() {
        float depth = smoothstep( 10.24, 1.0, gl_FragCoord.z / gl_FragCoord.w );
        gl_FragColor = vec4( (vec3(0.0, 0.03, 0.05) + (texture2D( map, vUv ).xyz * 0.25)), depth );
        }
    </script>
    <!-- WebGL 2 shaders -->
    <script id="vs-particles-2" type="x-shader/x-vertex">
        uniform float pointSize;

        varying vec3 vPosition;

        void main() {
        vPosition = position;
        gl_PointSize = pointSize;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    </script>
    <script id="fs-particles-2" type="x-shader/x-fragment">
        varying vec3 vPosition;

        void main() {
        float depth = 1.0;//smoothstep( 10.24, 1.0, gl_FragCoord.z / gl_FragCoord.w );
        gl_FragColor = vec4( (vec3(0.01, 0.02, 0.03) + (abs(vPosition) * 0.25)), depth );
        //gl_FragColor = vec4( (vPosition), depth );
        }
    </script>
    <script>
        function getQueryString(name, defaultValue) {
            var query = window.location.search.substring(1);
            var vars = query.split("&");
            for (var i = 0; i < vars.length; i++) {
                var pair = vars[i].split("=");
                if (pair[0] == name) {
                    return unescape(pair[1]);
                }
            }
            return defaultValue;
        }

        function getQueryValue(name, defaultValue) {
            var value = getQueryString(name, null);
            if (value == null) {
                return defaultValue;
            }
            return parseInt(value, 10);
        }

        var tempTex1, tempTex2;

        var container, canvas, gl;

        var timer = 0;
        var count = 0;

        var cloth_w = 50;
        var cloth_h = 50;
        var cfg_ui;

        var moved = false;
        var geometry;
        var scene, camera, light, camControl, renderer;
        var vbo_pos, vbo_pos2;
        var originGeometry, cube, mesh, material;
        var roomMesh, sphereMesh;

        var data, vtxIds, texture, points;
        var pinPongData;
        var roomMaterial;
        var guiStep = false;
        //var controls;
        var fboParticles, rtTexturePos, rtTexturePos2, simulationShader;

        //var width = getQueryValue('width', 1024);
        //var height = getQueryValue('height', 1024);
        var pointSize = getQueryValue('pointSize', 3.0);

        var maxFingers = 42;
        var fingers = [];
        var fingertipSize = 0.18;
        var handOffset = new THREE.Vector3(0, -2.5, 0.0);

        var leapController = new Leap.Controller();

        var isWebGL2 = false;

        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        var usrControl = {
            testDragMesh: null,
            plane: null,
            selection: null,
            itrOffset: new THREE.Vector3(),
            pinObjects: [],
            uniformPins: [0.0, 0.0, 0.0, 0.0],
        };

        function onMouseMove(event) {
            event.preventDefault();
            // Get mouse position
            var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

            // Get 3D vector from 3D mouse position using 'unproject' function
            var vector = new THREE.Vector3(mouseX, mouseY, 1);
            vector.unproject(camera);
            // Set the raycaster position
            raycaster.set(camera.position, vector.sub(camera.position).normalize());
            if (usrControl.selection) {
                // Check the position where the plane is intersected
                var intersects = raycaster.intersectObject(usrControl.plane);
                // Reposition the object based on the intersection point with the plane
                usrControl.selection.position.copy(intersects[0].point.sub(usrControl.itrOffset));
                usrControl.uniformPins[0] = usrControl.selection.position.x;
                usrControl.uniformPins[1] = usrControl.selection.position.y;
                usrControl.uniformPins[2] = usrControl.selection.position.z;
                usrControl.uniformPins[3] = 1.0;

            } else {
                // Update position of the plane if need
                usrControl.uniformPins[3] = 0.0;

                var intersects = raycaster.intersectObjects(usrControl.pinObjects);
                if (intersects.length > 0) {
                    usrControl.plane.position.copy(intersects[0].object.position);
                    usrControl.plane.lookAt(camera.position);
                }

                if (!camControl.enabled) {
                    camControl = new THREE.OrbitControls(camera);//??!!
                    //camControl.enabled = true;
                }
            }
        }

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            canvas = document.createElement('canvas');

            var tryGL2 = getQueryValue('webgl2', 1);

            if (tryGL2) {
                // Try creating a WebGL 2 context first
                gl = canvas.getContext('webgl2', { antialias: false });
                if (!gl) {
                    gl = canvas.getContext('experimental-webgl2', { antialias: false });
                }
                isWebGL2 = !!gl;
                if (isWebGL2) {
                    console.log("I can haz flag, so WebGL 2 is yes!")
                }
            }

            renderer = new THREE.WebGLRenderer({ canvas: canvas, context: gl });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.sortObjects = false;
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1024);
            camera.position.y = 1.5;
            camera.position.z = 4;
            camera.lookAt(scene.position);

            clock = new THREE.Clock();

            camControl = new THREE.OrbitControls(camera, renderer.domElement);

            scene.add(camera);

            light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(0, 100, 0);
            scene.add(light);

            var backImage = THREE.ImageUtils.loadTexture("media/Back.png");
            var ceilImage = THREE.ImageUtils.loadTexture("media/Ceiling.png");
            var floorImage = THREE.ImageUtils.loadTexture("media/Floor.png");
            var sideImage = THREE.ImageUtils.loadTexture("media/Side.png");

            var roomMaterialArray = [
              new THREE.MeshBasicMaterial({ map: sideImage, side: THREE.BackSide }),
              new THREE.MeshBasicMaterial({ map: sideImage, side: THREE.BackSide }),
              new THREE.MeshBasicMaterial({ map: ceilImage, side: THREE.BackSide }),
              new THREE.MeshBasicMaterial({ map: floorImage, side: THREE.BackSide }),
              new THREE.MeshBasicMaterial({ map: backImage, side: THREE.BackSide }),
              new THREE.MeshBasicMaterial({ map: backImage, side: THREE.BackSide })
            ];
            roomMaterial = new THREE.MeshFaceMaterial(roomMaterialArray);

            var roomGeometry = new THREE.BoxGeometry(10.24, 6, 5.12);
            roomMesh = new THREE.Mesh(roomGeometry, roomMaterial);
            roomMesh.doubleSided = true;
            scene.add(roomMesh);


            // prepare text geometry
           
            var textGeometry = new THREE.TextGeometry(isWebGL2 ? "WebGL 2 Cloth Simulation" : "WebGL Cloth Simulation", {
                size: 0.4, // Font size
                height: 0.05, // Font height (depth)
                font: 'helvetiker', // Font family
                weight: 'bold', // Font weight
                style: 'normal', // Font style
                curveSegments: 5, // Amount of curve segments
                bevelThickness: 0.02, // Bevel thickness
                bevelSize: 0.02, // Bevel size
                bevelEnabled: true, // Enable/Disable the bevel
                material: 0, // Main material
                extrudeMaterial: 1 // Side (extrude) material
            });

        var materialFront = new THREE.MeshPhongMaterial({ map: texture, color: 0xffff00, emissive: 0x888888 });
        
        var materialSide = new THREE.MeshPhongMaterial({ map: texture, color: 0xff00ff, emissive: 0x444444 });
    
        var textMaterial = new THREE.MeshFaceMaterial([ materialFront, materialSide ]);

        var textMesh = new THREE.Mesh(textGeometry, textMaterial);

        textMesh.castShadow = true;

        textMesh.position.set(-3.4,1.6,-2.6);
        //textMesh.rotation.x = -0.3;

        scene.add(textMesh);


            var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x00008B });
            var sphereGeom = new THREE.SphereGeometry(0.3, 100, 100);
            //sphereMesh = new THREE.Mesh(sphereGeom, sphereMaterial);
            sphereMesh = new THREE.Mesh(sphereGeom, roomMaterial);
            sphereMesh.position.x = 0.5;
            sphereMesh.position.y = 0.45;
            sphereMesh.position.z = 0.4;
            sphereMesh.visible = false;
            scene.add(sphereMesh);

            //Move plane
            usrControl.plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(500, 500, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            usrControl.plane.visible = false;
            scene.add(usrControl.plane);

            //https://www.script-tutorials.com/webgl-with-three-js-lesson-10/
            var testDragGeo = new THREE.SphereGeometry(0.03, 10, 10);
            var testDragMat = new THREE.MeshPhongMaterial({ color: 0xEE00EE });
            //usrControl.testDragMesh = new THREE.Mesh(testDragGeo, testDragMat);
            usrControl.testDragMesh = new THREE.Mesh(testDragGeo, roomMaterial);
            usrControl.testDragMesh.position.x = 0.0;
            usrControl.testDragMesh.position.y = 1.0;
            scene.add(usrControl.testDragMesh);
            usrControl.pinObjects.push(usrControl.testDragMesh);
            //
            if (!isWebGL2 && !renderer.context.getExtension('OES_texture_float')) {
                alert('OES_texture_float is not :(');
            }

            // Start Creation of DataTexture
            cloth_h = 50;
            cloth_w = cloth_h;
            
            data = new Float32Array(cloth_w * cloth_h * 4);
            vtxIds = new Float32Array(cloth_w * cloth_h * 4);
            for (var i = 0, t = 0, x = 0; x <cloth_w; x++) {
                for (var y = 0; y < cloth_h; y++) {
                     data[i + 0] = x * 1.0 / cloth_w;
                    data[i + 1] = 1.0;
                    data[i + 2] = y * 1.0 / cloth_h; //-y * 1.0 / cloth_h;
                    data[i + 3] = 0.1;
                    
                    vtxIds[i + 0] = t;
                    vtxIds[i + 1] = t;
                    vtxIds[i + 2] = t;
                    vtxIds[i + 3] = t;
                    
                    i += 4;
                    t++;
                }
            }

            if (isWebGL2) {
                vbo_pos = new THREE.BufferGeometry();
                vbo_pos.addAttribute('position', new THREE.BufferAttribute(data, 4));
                vbo_pos.addAttribute('color', new THREE.BufferAttribute(data, 4));
                vbo_pos.addAttribute('trytry', new THREE.BufferAttribute(vtxIds, 4));

                vbo_pos2 = vbo_pos.clone();
                material = new THREE.ShaderMaterial({
                    uniforms: {
                        "pointSize": { type: "f", value: pointSize }
                    },
                    attributes: {
                        "trytry": { type: "f", value: [] }
                    },
                    vertexShader: document.getElementById('vs-particles-2').textContent,
                    fragmentShader: document.getElementById('fs-particles-2').textContent,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: true,
                    transparent: true
                });

                gpgpu = new GPGPU2(renderer, cloth_w, cloth_h);
                gpgpu.init(data);
                simulationShader = new GPGPU2.SimulationShader2(renderer, cloth_w, cloth_h);

                //WebGL 2 mesh
                mesh = new THREE.PointCloud(vbo_pos, material);
            } else {
                //Try triangle:
                var triangleGeo = new THREE.Geometry();
                triangleGeo.vertices.push(
                    new THREE.Vector3(-1, 1, 0),
                    new THREE.Vector3(-1, -1, 0),
                    new THREE.Vector3(1, -1, 0),
                    new THREE.Vector3(2, -2, 0),
                    new THREE.Vector3(3, -2, 0)
                 );

                triangleGeo.faces.push(new THREE.Face3(0, 1, 2));
                triangleGeo.faces.push(new THREE.Face3(2, 3, 4));
                triangleGeo.computeBoundingSphere();

                var triangleMat = new THREE.ShaderMaterial({
                    vertexShader: [
                        'void main() {',
                        //'position.x+=0.1;',
                        '  gl_Position = projectionMatrix * modelViewMatrix * vec4( position + vec3(2.5,0.0,0.0), 1.0 );',
                        '}',
                    ].join('\n'),
                    fragmentShader: [
                        'void main() {',
                        '  gl_FragColor = vec4(1.0,0.0,1.0,1.0);',
                        '}',
                    ].join('\n'),
                });

                var triangleMesh = new THREE.Mesh(triangleGeo, triangleMat);
                scene.add(triangleMesh);


                //WebGL 1+
                texture = new THREE.DataTexture(data, cloth_w, cloth_h, THREE.RGBAFormat, THREE.FloatType);
                texture.minFilter = THREE.NearestFilter;
                texture.magFilter = THREE.NearestFilter;
                texture.needsUpdate = true;

                // zz85 - fbo init

                rtTexturePos = new THREE.WebGLRenderTarget(cloth_w, cloth_h, {
                    wrapS: THREE.RepeatWrapping,
                    wrapT: THREE.RepeatWrapping,
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat,
                    type: THREE.FloatType,
                    stencilBuffer: false
                });

                rtTexturePos2 = rtTexturePos.clone();

                gpgpu = new GPGPU(renderer);
                simulationShader = new GPGPU.SimulationShader();
                simulationShader.setOriginsTexture(texture);

                geometry = new THREE.Geometry();

                for (var i = 0, l = cloth_w * cloth_h; i < l; i++) {
                    var vertex = new THREE.Vector3();
                    vertex.x = (i % cloth_w) / cloth_w;
                    vertex.y = Math.floor(i / cloth_w) / cloth_h;
                    geometry.vertices.push(vertex);
                }
                //Testing.
                geometry.faces.push(new THREE.Face3(0, 1, cloth_w));
                geometry.faces.push(new THREE.Face3(1, 2, cloth_w + 1));
                geometry.faces.push(new THREE.Face3(2, 3, cloth_w + 2));
                geometry.faces.push(new THREE.Face3(3, 4, cloth_w + 3));

                material = new THREE.ShaderMaterial({
                    uniforms: {
                        "map": { type: "t", value: texture },
                        "width": { type: "f", value: cloth_w },
                        "height": { type: "f", value: cloth_h },
                        "pointSize": { type: "f", value: pointSize }
                    },
                    vertexShader: document.getElementById('vs-particles').textContent,
                    fragmentShader: document.getElementById('fs-particles').textContent,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: true,
                    transparent: true
                });
                //WebGl 1 Mesh
                mesh = new THREE.PointCloud(geometry, material);
               // mesh = new THREE.Mesh(geometry, material);
            }

            
            //mesh = new THREE.Points(vbo_pos, material);
            scene.add(mesh);

            window.addEventListener('start-simulation', onStartSimulation);
            window.addEventListener('step-simulation', onStepSimulation);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('mouseup', onMouseUp, false);
        }
        function onMouseDown(event) {
            moved = false;
            var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            var vector = new THREE.Vector3(mouseX, mouseY, 1);
            vector.unproject(camera);
            raycaster.set(camera.position, vector.sub(camera.position).normalize());
            //var intersects = raycaster.intersectObjects(scene.children);
            var intersects = raycaster.intersectObjects(usrControl.pinObjects);
            if (intersects.length > 0) {
                camControl.enabled = false;

                usrControl.selection = intersects[0].object;
                var intersects = raycaster.intersectObject(usrControl.plane);
                usrControl.itrOffset.copy(intersects[0].point).sub(usrControl.plane.position);//???!!
            }
        }
        function onMouseUp(event) {
            usrControl.selection = null;
            //camControl.enabled = true;

        }
        function onStartSimulation(event) {
            //TODO: reset and start simulation
            //cfg_ui.setPause(false);
            usrControl.testDragMesh.position.x = 0.0;
            usrControl.testDragMesh.position.y = 1.0;
            usrControl.testDragMesh.position.z = 0.0;
            cloth_h = cfg_ui.getClothDim();
            cloth_w = cloth_h;
            var mass = cfg_ui.getParticleMass();

            data = new Float32Array(cloth_w * cloth_h * 4);
            vtxIds = new Float32Array(cloth_w * cloth_h * 4);
            for (var i = 0, t = 0, x = 0; x < cloth_w; x++) {
                for (var y = 0; y < cloth_h; y++) {
                    data[i + 0] = x * 1.0 / cloth_w;
                    data[i + 1] = 1.0;
                    data[i + 2] = y * 1.0 / cloth_h; //-y * 1.0 / cloth_h;
                    data[i + 3] = 0.1;

                    vtxIds[i + 0] = t;
                    vtxIds[i + 1] = t;
                    vtxIds[i + 2] = t;
                    vtxIds[i + 3] = t;

                    i += 4;
                    t++;
                }
            }
            if (isWebGL2) {
                vbo_pos = new THREE.BufferGeometry();
                vbo_pos.addAttribute('position', new THREE.BufferAttribute(data, 4));
                vbo_pos.addAttribute('color', new THREE.BufferAttribute(data, 4));
                vbo_pos.addAttribute('trytry', new THREE.BufferAttribute(vtxIds, 4));
                vbo_pos2 = vbo_pos.clone();
                material = new THREE.ShaderMaterial({
                    uniforms: {
                        "pointSize": { type: "f", value: pointSize }
                    },
                    attributes: {
                        "trytry": { type: "f", value: [] }
                    },
                    vertexShader: document.getElementById('vs-particles-2').textContent,
                    fragmentShader: document.getElementById('fs-particles-2').textContent,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: true,
                    transparent: true
                });
                gpgpu = new GPGPU2(renderer, cloth_w, cloth_h);
                gpgpu.init(data);
                simulationShader = new GPGPU2.SimulationShader2(renderer, cloth_w, cloth_h);
                //mesh = new THREE.PointCloud(vbo_pos, material);
            } else {

                //WebGL 1+
                texture = new THREE.DataTexture(data, cloth_w, cloth_h, THREE.RGBAFormat, THREE.FloatType);
                texture.minFilter = THREE.NearestFilter;
                texture.magFilter = THREE.NearestFilter;
                texture.needsUpdate = true;

                // zz85 - fbo init

                rtTexturePos = new THREE.WebGLRenderTarget(cloth_w, cloth_h, {
                    wrapS: THREE.RepeatWrapping,
                    wrapT: THREE.RepeatWrapping,
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat,
                    type: THREE.FloatType,
                    stencilBuffer: false
                });

                rtTexturePos2 = rtTexturePos.clone();

                gpgpu = new GPGPU(renderer);
                simulationShader = new GPGPU.SimulationShader();
                simulationShader.setOriginsTexture(texture);
                simulationShader.setClothDim(cloth_w);
                //*
                geometry = new THREE.Geometry();

                for (var i = 0, l = cloth_w * cloth_h; i < l; i++) {
                    var vertex = new THREE.Vector3();
                    vertex.x = (i % cloth_w) / cloth_w;
                    vertex.y = Math.floor(i / cloth_w) / cloth_h;
                    geometry.vertices.push(vertex);
                }//*/

                material = new THREE.ShaderMaterial({
                    uniforms: {
                        "map": { type: "t", value: rtTexturePos },
                        "width": { type: "f", value: cloth_w },
                        "height": { type: "f", value: cloth_h },
                        "pointSize": { type: "f", value: pointSize }
                    },
                    vertexShader: document.getElementById('vs-particles').textContent,
                    fragmentShader: document.getElementById('fs-particles').textContent,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: true,
                    transparent: true
                });
                count = 0;
                //mesh.material = material;
                scene.remove(mesh);
                //scene.add(mesh);
                mesh = new THREE.PointCloud(geometry, material);
            }
        }
        function onStepSimulation(event) {
            cfg_ui.setPause(true);
            guiStep = true;
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize, false);

        function render() {

            requestAnimationFrame(render);

            sphereMesh.visible = (cfg_ui.getRigid() == 0);

            //*/
            if ((!cfg_ui.getPause()) || guiStep) {
                simulationShader.setTimer(cfg_ui.getTimeStep());

                if (count > 20 && !isWebGL2) simulationShader.setStart(0);

                timer += 1;

                // Ugly hack to make the particle mesh always draw last
                scene.remove(mesh); scene.add(mesh);

                if (isWebGL2) {
                    if (count % 2 === 0) {
                        gpgpu.pass(simulationShader, vbo_pos2, vbo_pos, cfg_ui, usrControl);
                        mesh.geometry = vbo_pos2;
                    } else {
                        gpgpu.pass(simulationShader, vbo_pos, vbo_pos2, cfg_ui, usrControl);
                        mesh.geometry = vbo_pos;
                    }
                } else {
                    simulationShader.setPositionsTexture(rtTexturePos);
                    if (count < 15)
                        gpgpu.initVel(simulationShader);
                    gpgpu.pass(simulationShader, rtTexturePos2, cfg_ui, usrControl);
                    material.uniforms.map.value = rtTexturePos;
                    var a = rtTexturePos;
                    rtTexturePos = rtTexturePos2;
                    rtTexturePos2 = a;
                }
                count++;
                guiStep = !guiStep;
            }

            camControl.update();
            renderer.render(scene, camera);
        }

        cfg_ui = new UI_cfg();
        cfg_ui.init();

        init();

        render();

    </script>
</body>
</html>
