
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        color: #ffffff;

        font-family: Monospace;
        font-size: 13px;
        text-align: center;
        font-weight: bold;

        position: absolute;
        top: 0px; width: 100%;
        padding: 5px;
      }

      a {

        color: #0040ff;

      }
    </style>
  </head>
  <body>
    <script src="lib/dat.gui.js"></script>


    <script src="js/three.js"></script>
    <script src="js/GPGPU.js"></script>
    <script src="js/GeometryUtils.js"></script>
    <script src="js/gpgpu/SimulationShader.js"></script>
    <script src="lib/OrbitControls.js"></script>
    <script src="js/leap-0.6.4.min.js"></script>
    <script src="js/leap-plugins-0.1.6.1.js"></script>
    <script src="js/leap.rigged-hand-0.1.3.min.js"></script>
    <script src="js/ui.js"></script>

    <script src="helvetiker_bold.typeface.js"></script>

    <!-- WebGL 1 shaders -->
    <script id="vs-particles" type="x-shader/x-vertex">
          uniform sampler2D map;
          uniform float width;
          uniform float height;
          uniform float pointSize;
          varying vec2 vUv;
          varying vec4 vPosition;
          void main() {
          vUv = position.xy + vec2( 0.5 / width, 0.5 / height );
          vec3 color = texture2D( map, vUv ).rgb;
          gl_PointSize = pointSize;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( color, 1.0 );
          }
     </script>

     <script id="fs-particles" type="x-shader/x-fragment">
          uniform sampler2D map;
          varying vec2 vUv;
          varying vec4 vPosition;
          void main() {
          float depth = smoothstep( 10.24, 1.0, gl_FragCoord.z / gl_FragCoord.w );
          gl_FragColor = vec4( (vec3(0.0, 0.03, 0.05) + (texture2D( map, vUv ).xyz * 0.25)), depth );
          }
    </script>

    <!-- WebGL 2 shaders -->
    <script id="vs-particles-2" type="x-shader/x-vertex">
      uniform float pointSize;

      varying vec3 vPosition;

      void main() {
        vPosition = position;
        gl_PointSize = pointSize;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>

    <script id="fs-particles-2" type="x-shader/x-fragment">
      varying vec3 vPosition;

      void main() {
        float depth = 1.0;//smoothstep( 10.24, 1.0, gl_FragCoord.z / gl_FragCoord.w );
        gl_FragColor = vec4( (vec3(0.01, 0.02, 0.03) + (abs(vPosition) * 0.25)), depth );
        //gl_FragColor = vec4( (vPosition), depth );
      }
    </script>

    <script>
      function getQueryString(name, defaultValue) {
        var query = window.location.search.substring(1);
        var vars = query.split("&");
        for (var i = 0; i < vars.length; i++) {
          var pair = vars[i].split("=");
          if (pair[0] == name) {
            return unescape(pair[1]);
          }
        }
        return defaultValue;
      }

      function getQueryValue(name, defaultValue) {
          var value = getQueryString(name, null);
          if (value == null) {
              return defaultValue;
          }
          return parseInt(value, 10);
      }

      var container, canvas, gl;

      var cloth_w, cloth_h;
      var cfg_ui;

      var moved = false;

      var scene, camera, light, camControl, renderer;
      var vbo_pos, vbo_pos2;
      var originGeometry, cube, mesh, material;
      var roomMesh,sphereMesh;

      var data, vtxIds, texture, points;
      var roomMaterial;
      var guiStep = false;
      //var controls;
      var fboParticles, rtTexturePos, rtTexturePos2, simulationShader;

      var width = getQueryValue('width', 1024);
      var height = getQueryValue('height', 1024);
      var pointSize = getQueryValue('pointSize', 3.0);

      var maxFingers = 42;
      var fingers = [];
      var fingertipSize = 0.18;
      var handOffset = new THREE.Vector3(0,-2.5, 0.0);

      var leapController = new Leap.Controller();

      var isWebGL2 = false;

      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      var usrControl = {
          testDragMesh: null,
          plane: null,
          selection: null,
          itrOffset: new THREE.Vector3(),
          pinObjects: [],
          uniformPins: new THREE.Vector4(),//[0.0,0.0,0.0,0.0],
      };

      function onMouseMove(event) {
          event.preventDefault();
          // Get mouse position
          var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
          var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

          // Get 3D vector from 3D mouse position using 'unproject' function
          var vector = new THREE.Vector3(mouseX, mouseY, 1);
          vector.unproject(camera);
          // Set the raycaster position
          raycaster.set(camera.position, vector.sub(camera.position).normalize());
          if (usrControl.selection) {
              // Check the position where the plane is intersected
              var intersects = raycaster.intersectObject(usrControl.plane);
              // Reposition the object based on the intersection point with the plane
              usrControl.selection.position.copy(intersects[0].point.sub(usrControl.itrOffset));
              usrControl.uniformPins.x = usrControl.selection.position.x;
              usrControl.uniformPins.y = usrControl.selection.position.y;
              usrControl.uniformPins.z = usrControl.selection.position.z;
              usrControl.uniformPins.w = 1.0;

          } else {
              // Update position of the plane if need
              usrControl.uniformPins.w = 0.0;
              var intersects = raycaster.intersectObjects(usrControl.pinObjects);
              if (intersects.length > 0) {
                  usrControl.plane.position.copy(intersects[0].object.position);
                  usrControl.plane.lookAt(camera.position);
              }
              if (!camControl.enabled) {
                  camControl = new THREE.OrbitControls(camera);//??!!
                  //camControl.enabled = true;
              }
          }
      }

      function init() {
          container = document.createElement('div');
          document.body.appendChild(container);

          canvas = document.createElement('canvas');

          var tryGL2 = getQueryValue('webgl2', 1);

          if (tryGL2) {
              // Try creating a WebGL 2 context first
              gl = canvas.getContext('webgl2', { antialias: false });
              if (!gl) {
                  gl = canvas.getContext('experimental-webgl2', { antialias: false });
              }
              isWebGL2 = !!gl;
              if (isWebGL2) {
                  console.log("I can haz flag, so WebGL 2 is yes!")
              }
          }

          renderer = new THREE.WebGLRenderer({ canvas: canvas, context: gl });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.sortObjects = false;
          container.appendChild(renderer.domElement);

          scene = new THREE.Scene();

          camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1024);
          camera.position.y = 1.5;
          camera.position.z = 4;
          camera.lookAt(scene.position);

          clock = new THREE.Clock();

          camControl = new THREE.OrbitControls(camera, renderer.domElement);

          scene.add(camera);

          light = new THREE.DirectionalLight(0xffffff, 0.5);
          light.position.set(0, 100, 0);
          scene.add(light);

          var backImage = THREE.ImageUtils.loadTexture("media/Back.png");
          var ceilImage = THREE.ImageUtils.loadTexture("media/Ceiling.png");
          var floorImage = THREE.ImageUtils.loadTexture("media/Floor.png");
          var sideImage = THREE.ImageUtils.loadTexture("media/Side.png");

          var roomMaterialArray = [
            new THREE.MeshBasicMaterial({ map: sideImage, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ map: sideImage, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ map: ceilImage, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ map: floorImage, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ map: backImage, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ map: backImage, side: THREE.BackSide })
          ];
          roomMaterial = new THREE.MeshFaceMaterial(roomMaterialArray);

          var roomGeometry = new THREE.BoxGeometry(10.24, 6, 5.12);
          roomMesh = new THREE.Mesh(roomGeometry, roomMaterial);
          roomMesh.doubleSided = true;
          scene.add(roomMesh);
          var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x00008B });
          var sphereGeom = new THREE.SphereGeometry(0.3, 100, 100);
          sphereMesh = new THREE.Mesh(sphereGeom, sphereMaterial);
          sphereMesh.position.x = 0.5;
          sphereMesh.position.y = 0.45;
          sphereMesh.position.z = 0.4;
          scene.add(sphereMesh);

          //Move plane
          usrControl.plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(500, 500, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffffff }));
          usrControl.plane.visible = false;
          scene.add(usrControl.plane);

          //https://www.script-tutorials.com/webgl-with-three-js-lesson-10/
          var testDragGeo = new THREE.SphereGeometry(0.03, 10, 10);
          var testDragMat = new THREE.MeshPhongMaterial({ color: 0xEE00EE });
          usrControl.testDragMesh = new THREE.Mesh(testDragGeo, testDragMat);
          usrControl.testDragMesh.position.x = 0.0;
          usrControl.testDragMesh.position.y = 1.0;
          usrControl.testDragMesh.position.z = 0.0;

          usrControl.uniformPins.x = 0.0;
          usrControl.uniformPins.y = 1.0;
          usrControl.uniformPins.z = 0.0;

          scene.add(usrControl.testDragMesh);
          usrControl.pinObjects.push(usrControl.testDragMesh);
          //
          if (!isWebGL2 && !renderer.context.getExtension('OES_texture_float')) {
              alert('OES_texture_float is not :(');
          }

          // Start Creation of DataTexture
          cloth_h = 50;
          cloth_w = cloth_h;

          data = new Float32Array(cloth_w * cloth_h * 4);
          vtxIds = new Float32Array(cloth_w * cloth_h * 4);
          for (var i = 0, t = 0, x = 0; x < cloth_w; x++) {
              for (var y = 0; y < cloth_h; y++) {
                  data[i + 0] = x * 1.0 / cloth_w;
                  data[i + 1] = 1.0;
                  data[i + 2] = y * 1.0 / cloth_h; //-y * 1.0 / cloth_h;
                  data[i + 3] = 0.1;

                  vtxIds[i + 0] = t;
                  vtxIds[i + 1] = t;
                  vtxIds[i + 2] = t;
                  vtxIds[i + 3] = t;

                  i += 4;
                  t++;
              }
          }
          if (isWebGL2) {
              vbo_pos = new THREE.BufferGeometry();
              vbo_pos.addAttribute('position', new THREE.BufferAttribute(data, 4));
              vbo_pos.addAttribute('color', new THREE.BufferAttribute(data, 4));
              vbo_pos.addAttribute('trytry', new THREE.BufferAttribute(vtxIds, 4));

              vbo_pos2 = vbo_pos.clone();
              material = new THREE.ShaderMaterial({
                  uniforms: {
                      "pointSize": { type: "f", value: pointSize }
                  },
                  attributes: {
                      "trytry": { type: "f", value: [] }
                  },
                  vertexShader: document.getElementById('vs-particles-2').textContent,
                  fragmentShader: document.getElementById('fs-particles-2').textContent,
                  blending: THREE.AdditiveBlending,
                  depthWrite: false,
                  depthTest: true,
                  transparent: true
              });

              gpgpu = new GPGPU2(renderer,cloth_w,cloth_h);
              gpgpu.init(data);
              simulationShader = new GPGPU2.SimulationShader2(renderer, cloth_w,cloth_h);
          } else {
              
              //WebGL 1+
              //textures?? what for?? fragment shader?pin-pong texture?
              
              texture = new THREE.DataTexture(data, cloth_w, cloth_h, THREE.RGBAFormat, THREE.FloatType);
              texture.minFilter = THREE.NearestFilter;
              texture.magFilter = THREE.NearestFilter;
              texture.needsUpdate = true;

              rtTexturePos = new THREE.WebGLRenderTarget(cloth_w, cloth_h, {
                  wrapS: THREE.RepeatWrapping,
                  wrapT: THREE.RepeatWrapping,
                  minFilter: THREE.NearestFilter,
                  magFilter: THREE.NearestFilter,
                  format: THREE.RGBAFormat,
                  type: THREE.FloatType,
                  stencilBuffer: false
              });
              rtTexturePos2 = rtTexturePos.clone();

              gpgpu = new GPGPU(renderer);
              simulationShader = new GPGPU2.SimulationShader1();

              vbo_pos = new THREE.Geometry();

              for (var i = 0, t = 0, x = 0; x < cloth_w; x++) {
                  for (var y = 0; y < cloth_h; y++) {

                      var vertex = new THREE.Vector3();
                      vertex.x = x * 1.0 / cloth_w;
                      vertex.y = 1.0;
                      vertex.z = y * 1.0 / cloth_h; //-y * 1.0 / cloth_h;
                      vbo_pos.vertices.push(vertex);
                      /*
                      vtxIds[i + 0] = t;
                      vtxIds[i + 1] = t;
                      vtxIds[i + 2] = t;
                      vtxIds[i + 3] = t;
                      */
                      i += 4;
                      t++;
                  }
              }
              material = new THREE.ShaderMaterial({
                  uniforms: {
                      "map": { type: "t", value: rtTexturePos },
                      "width": { type: "f", value: cloth_w },
                      "height": { type: "f", value: cloth_h },
                      "pointSize": { type: "f", value: pointSize }
                  },
                  vertexShader: document.getElementById('vs-particles').textContent,
                  fragmentShader: document.getElementById('fs-particles').textContent,
                  blending: THREE.AdditiveBlending,
                  depthWrite: false,
                  depthTest: true,
                  transparent: true
              });

          }

          mesh = new THREE.PointCloud(vbo_pos, material);
          //mesh = new THREE.Points(vbo_pos, material);
          scene.add(mesh);

          window.addEventListener('start-simulation', onStartSimulation);
          window.addEventListener('step-simulation', onStepSimulation);
          window.addEventListener('mousemove', onMouseMove, false);
          window.addEventListener('mousedown', onMouseDown,false);
          window.addEventListener('mouseup', onMouseUp, false);

      }
      function onMouseDown(event)
      {
          moved = false;
          var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
          var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
          var vector = new THREE.Vector3(mouseX, mouseY, 1);
          vector.unproject(camera);
          raycaster.set(camera.position, vector.sub(camera.position).normalize());
          //var intersects = raycaster.intersectObjects(scene.children);
          var intersects = raycaster.intersectObjects(usrControl.pinObjects);
          if (intersects.length > 0) {
              camControl.enabled = false;

              usrControl.selection = intersects[0].object;
              var intersects = raycaster.intersectObject(usrControl.plane);
              usrControl.itrOffset.copy(intersects[0].point).sub(usrControl.plane.position);//???!!
              debugger;
          }
      }
      function onMouseUp(event)
      {
          usrControl.selection = null;
          //camControl.enabled = true;

      }
      function onStartSimulation(event){
          //TODO: reset and start simulation
          //cfg_ui.setPause(false);
          usrControl.testDragMesh.position.x = 0.0;
          usrControl.testDragMesh.position.y = 1.0;
          usrControl.testDragMesh.position.z = 0.0;
          cloth_h = cfg_ui.getClothDim();
          cloth_w = cloth_h;
          var mass = cfg_ui.getParticleMass();

          data = new Float32Array(cloth_w * cloth_h * 4);
          vtxIds = new Float32Array(cloth_w * cloth_h * 4);
          for (var i = 0, t = 0, x = 0; x < cloth_w; x++) {
              for (var y = 0; y < cloth_h; y++) {
                  data[i + 0] = x * 1.0 / cloth_w;
                  data[i + 1] = 1.0;
                  data[i + 2] = y * 1.0 / cloth_h; //-y * 1.0 / cloth_h;
                  data[i + 3] = 0.1;

                  vtxIds[i + 0] = t;
                  vtxIds[i + 1] = t;
                  vtxIds[i + 2] = t;
                  vtxIds[i + 3] = t;

                  i += 4;
                  t++;
              }
          }

          vbo_pos = new THREE.BufferGeometry();
          vbo_pos.addAttribute('position', new THREE.BufferAttribute(data, 4));
          vbo_pos.addAttribute('color', new THREE.BufferAttribute(data, 4));
          vbo_pos.addAttribute('trytry', new THREE.BufferAttribute(vtxIds, 4));
          vbo_pos2 = vbo_pos.clone();
          material = new THREE.ShaderMaterial({
              uniforms: {
                  "pointSize": { type: "f", value: pointSize }
              },
              attributes: {
                  "trytry": { type: "f", value: [] }
              },
              vertexShader: document.getElementById('vs-particles-2').textContent,
              fragmentShader: document.getElementById('fs-particles-2').textContent,
              blending: THREE.AdditiveBlending,
              depthWrite: false,
              depthTest: true,
              transparent: true
          });
          gpgpu = new GPGPU2(renderer, cloth_w, cloth_h);
          gpgpu.init(data);
          simulationShader = new GPGPU2.SimulationShader2(renderer, cloth_w, cloth_h);
      }

      function onStepSimulation(event) {
          cfg_ui.setPause(true);
          guiStep = true;
      }
      function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      }

      window.addEventListener( 'resize', onWindowResize, false );

      var timer = 0;
      var count = 0;
      function render() {

          requestAnimationFrame(render);
          debugger;
          //*/
          if ((!cfg_ui.getPause())||guiStep) {
              simulationShader.setTimer(0.0002);
              timer += 1;
              // Ugly hack to make the particle mesh always draw last
              scene.remove(mesh); scene.add(mesh);
              debugger;
              if (isWebGL2) {
                  if (count % 2 === 0) {
                      gpgpu.pass(simulationShader, vbo_pos2, vbo_pos, cfg_ui, usrControl);
                      mesh.geometry = vbo_pos2;
                  } else {
                      gpgpu.pass(simulationShader, vbo_pos, vbo_pos2, cfg_ui, usrControl);
                      mesh.geometry = vbo_pos;
                  }
              } else {
                  debugger;
                  if (count % 2 === 0) {
                      debugger;
                      gpgpu.pass(simulationShader.setPositionsTexture(rtTexturePos), rtTexturePos2);
                      debugger;
                      material.uniforms.map.value = rtTexturePos;
                      debugger;
                  } else {
                      debugger;
                      gpgpu.pass(simulationShader.setPositionsTexture(rtTexturePos2), rtTexturePos);
                      debugger;
                      material.uniforms.map.value = rtTexturePos2;
                      debugger;
                  }
                  debugger;
              }
              count++;
              guiStep = !guiStep;
          }

          camControl.update();
          renderer.render(scene, camera);
      }

      cfg_ui = new UI_cfg();
      cfg_ui.init();

      init();

      render();
    
    </script>
  </body>
</html>
